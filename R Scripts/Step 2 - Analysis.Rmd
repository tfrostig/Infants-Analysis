---
title: "Step 2 - Analysis (figures and tests)"
author: "Tzviel Frostig"
date: "2018 M09 20"
output:
  html_document:
    df_print: paged
  word_document: default
editor_options:
  chunk_output_type: console
---


```{r setup, include=FALSE}



source.dir <- dirname(getwd())
setwd(source.dir)

set.seed(999) 
knitr::opts_chunk$set(echo = F,
                      warning = F,
                      message = F,
                      fig.width = 16,
                      fig.height = 14,
                      dpi = 150,
                      fig.path = paste0(source.dir,'/Output/Images/'))


setwd('R Scripts')
source('Package required.R')
source('Functions.R')
source('Plotting Functions.R')

output.dir <- paste0(source.dir, '/Output/')
smooth.see.list  <- readRDS(GetObjects(output.dir, 'smooth.see.list')[1])
center.list      <- readRDS(GetObjects(output.dir, 'center_list'))
object.list      <- readRDS(GetObjects(output.dir, 'object_list'))
parameter.DF     <- read.csv(GetObjects(output.dir, 'Updated'), stringsAsFactors = F)
  
### Defining parameters for ggplot 

opts   <- theme(axis.title = element_blank(), 
                axis.text = element_blank(),
                axis.line = element_blank(),
                legend.position = 'none', 
                panel.spacing = unit(0, 'null'),
                axis.ticks.length = unit(0, 'null'),
                plot.title = element_text(size=22),
                plot.margin = unit(c(0.5,-0.75,0.5,-0.75), "cm"))


opts.perm <- theme(plot.title = element_text(size = 22), 
                   axis.title	= element_text(size = 20),
                   legend.text = element_text(size = 18),
                   strip.text.y = element_text(size = 18),
                   strip.text.x = element_text(size = 18))

```

### Heatmaps (Figure 2 a, b) 

Parameters used are: 
\begin{enumerate} 
\item Fans are located only on peaks (Not on the mother). 
\item Gaussian smoother parameter are sig = 14, and n = 63. 
\item Radius of visit (small) is 30, radius of large circle is 50. 
\item No tessilation 
\item Maximum finding (as opposed of island finding), only top 4% peaks. 
\item The contours are spaced at the the quantile 0.1,0.2,... of the smoothed time spent at a 1cm * 1cm 
\end{enumerate} 

```{r heatmaps, include = FALSE}


plot.heat.list <- list()
time.spent.vec <- NA
for (j in 1:nrow(parameter.DF)) { 
  temp.obj.list  <- object.list[[j]]
  mother.coord   <- temp.obj.list[['Mother']]
  temp.mom.cent  <- apply(mother.coord, 2, mean)
  
  ## Creating Heatmap 
  heatmap.temp <- HeatMaker(smooth.table = smooth.see.list[[j]],
                            rad.draw = 25, 
                            rad.calc = 30, 
                            rad.mom = 0, 
                            quant = 0.96, 
                            find.max = TRUE,
                            mom.cent = temp.mom.cent,
                            sig = 14, 
                            n = 63)
  
  temp.heat  <- heatmap.temp$Heatmap
  temp.visit <- heatmap.temp$Visit
  temp.arc   <- heatmap.temp$Arcs
  #temp.tess  <- heatmap.temp$Voroni ## Not used 
  temp.plot <- DrawHeat(temp.heat, temp.visit, temp.arc)
  for (i in 1:length(temp.obj.list)) { 
    temp.plot <- temp.plot + DrawGG(temp.obj.list[[i]]) 
  }
  temp.plot <- temp.plot + 
  DrawRectangleGG2(mother.coord, col.temp = 'green', alpha = 0.1) +
  labs(caption = parameter.DF$Name[j]) + theme(plot.caption = element_text(hjust=0.5, size=23))
  plot.heat.list[[j]] <- temp.plot
  time.spent.vec[j] <- mean(temp.heat[,3] > 0)
}

```

#### Plotting (Figure 1 a) 

```{r Figure 2 a - heatmap TD,fig.height= 12, fig.width=16}

grid.arrange(plot.heat.list[[3]] + opts, plot.heat.list[[5]] + opts, plot.heat.list[[6]] + opts,
             plot.heat.list[[8]] + opts, plot.heat.list[[9]] + opts , plot.heat.list[[11]] + opts
             ,nrow = 2 , ncol = 3)




```

#### Plotting (Figure 2 b)

```{r Figure 2 b - Heatmap NTD, fig.height= 12, fig.width=16}

grid.arrange(plot.heat.list[[1]] + opts, plot.heat.list[[2]] + opts, plot.heat.list[[4]] + opts,
             plot.heat.list[[7]] + opts, plot.heat.list[[10]] + opts, plot.heat.list[[12]] + opts
             ,nrow = 2 , ncol = 3 )
```


### Explaination of interaction plot (Figure S2)  

```{r Figure S2 - Interaction plot help, fig.height= 8, fig.width=12}
## Giving colors to objects 
cols <- magma(7)
obj.names   <- names(object.list[[1]])
#names(cols) <- obj.names
names(cols) <- c('Mother', 'Service Door',  'Exit Door', 'Basket', 'Table', 'Cylinder','Cabinet')


## Intializing 
## Taking larger radius as the the radius of each object would be subtracted from it 
rad.vec <- seq(1,120,1)
plot.list <- list()
arc.df.list <- list()
plot.heat.list <- list()

## Creating distance vector 
dist.vec <- c(rep(200, 12000), 
              seq(200, 20, -0.1),
              rep(20,2000), 
              seq(20, 5, -0.1), 
              seq(5, 0,-0.01), 
              rep(0, 2000),
              seq(0,200, 0.1))

n <- length(dist.vec)

## Plotting 
ang.vec     <- ((1:n) / n) * 2 * pi
## Creating Arcs 
arc.df <- data.frame('ID' = 1:length(dist.vec),
                     'Angle' = ang.vec, 
                     'Dist' = dist.vec,
                     'Obj' = factor('Mother', levels = obj.names))

arc.df <- arc.df %>% dplyr::filter(Dist < 120) 


## Creating Plot 
rad.vec <- seq(1,120,1)
rad.choice <- 120 
temp.plot <- ggplot(arc.df) 
for (i in 1:rad.choice) { 
  temp.plot <- temp.plot + geom_path(data = circleFun(r = rad.vec[i]), 
                                     aes(x,y),
                                     color = 'grey', size = 0.75) 
}
  temp.plot <- temp.plot  + geom_segment(aes(x = Dist * sin(Angle),
                                             y = Dist * cos(Angle),
                                             xend = rad.choice * sin(Angle),
                                             yend = rad.choice * cos(Angle),
                                             group = ID, colour = Obj)
                                         , size = 2) + 
    geom_path(aes(x = Dist * sin(Angle), y = Dist * cos(Angle)),
              size = 2, 
              arrow = arrow(length = unit(0.03, "npc"))) + 
    ## Adding Arrow 
    geom_segment(aes(x = Dist[1] * sin(Angle[1]), 
                     y = Dist[1] * cos(Angle[1]),
                     xend = Dist[250] * sin(Angle[250]), 
                     yend = Dist[250] * cos(Angle[250])), 
                 size = 2,
                 arrow = arrow(length = unit(0.03, "npc"))) + 
    scale_colour_manual(values = cols, name = 'Temp')

temp.plot +  coord_fixed(ratio = 1) + 
  opts +  annotate("text",
                     y = seq(-12,-122,-20), x = rep(0,6),
                     label = paste0('R = ', seq(10,120,20)), col = 'black', size = 6) +
  ## Points for radiuses 
  geom_point(data = data.frame('x'= rep(0,6), 'y' = seq(-10,-120,-20)),
             aes(x = x, y = y)) +
  ## Segments indicating the amount of time  
  annotate("segment", 
         x = c(0,0,0),
         xend = c(0),
         y = c(0), 
         yend = c(120),
         colour = "black", size = 1.5, linetype = 3) + 
  annotate("text",
           y = c(128, 120 * cos(ang.vec[round(0.65 * n)]) - 15, 120 * cos(ang.vec[round(0.95 * n)]) + 8), 
           x = c(25, 120 * sin(ang.vec[round(0.65 * n)]) - 1, 120 * sin(ang.vec[round(0.95 * n)]) - 10), 
             label = c("0% of session", "65% of session", "95% of session"), size = 6) + 
  theme(text = element_text(size=20))

```

### Interaction plots (only mother) (Figure 3 a, b)

The distances are not from the permiter of the mother but from the center of the mother location. (The radiuses range from 1 to 120 CM). 

```{r}

for (j in 1:nrow(parameter.DF)) { 
  temp.smooth <- smooth.see.list[[j]]
  mom.cent    <- center.list[[j]][['Mother']][1:2]
  mom.rad     <- center.list[[j]][['Mother']][3]
  ## Plotting 
  dist.vec    <- sqrt((temp.smooth$x - mom.cent[1])^2 + (temp.smooth$y - mom.cent[2])^2)
  ang.vec     <- ((1:nrow(temp.smooth)) / nrow(temp.smooth)) * 2 * pi
  # dist.vec    <- pmax(0,dist.vec) # Removing the radius of mother, so it is distance from the edge 
  ## Creating Arcs 
  arc.df <- data.frame('ID' = 1:nrow(temp.smooth),
                       'Angle' = ang.vec, 
                       'Dist' = dist.vec,
                       'Obj' = factor('Mother', levels = obj.names))
  arc.df <- arc.df %>% dplyr::filter(Dist < max(rad.vec)) 

  temp.plot <- ggplot(arc.df) 
  for (i in 1:length(rad.vec)) { 
    temp.plot <- temp.plot + geom_path(data = circleFun(r = rad.vec[i]), 
                                       aes(x,y),
                                       color = 'grey', size = 0.75) 
  }
      temp.plot <- temp.plot  + geom_segment(aes(x = Dist * sin(Angle),
                                                 y = Dist * cos(Angle),
                                                 xend = max(rad.vec) * sin(Angle),
                                                 yend = max(rad.vec) * cos(Angle),
                                                 group = ID, colour = Obj)
                                                 , size = 2) + 
    scale_colour_manual(values = cols)
  
  plot.list[[j]] <- temp.plot +  
    coord_fixed(ratio = 1) + 
    labs(caption = parameter.DF$Name[j]) + theme(plot.caption = element_text(hjust=0.5, size = 14))

}



```


#### Arranging plots 

```{r, include=FALSE, echo = FALSE, warning=FALSE}
TD.int.plot <- grid.arrange(plot.list[[3]] + opts, plot.list[[5]] + opts, plot.list[[6]] + opts,
                            plot.list[[8]] + opts, plot.list[[9]] + opts , plot.list[[11]] + opts,
                            padding = unit(0.1, "line"),
                            layout_matrix=rbind(c(1,2,3), c(4,5,6)))

NTD.int.plot <- grid.arrange(plot.list[[1]] + opts, plot.list[[2]] + opts, plot.list[[4]] + opts,
                            plot.list[[7]] + opts, plot.list[[10]] + opts, plot.list[[12]] + opts,
                            padding = unit(0.1, "line"),
                            layout_matrix=rbind(c(1,2,3), c(4,5,6)))

line.plot <- ggplot(NULL) + geom_abline(slope = 0, intercept = 0.5, size = 3) + opts
null.plot <- ggplot(NULL) + opts

A=textGrob("a", gp=gpar(fontface="bold", fontsize = 24))
B=textGrob("b", gp=gpar(fontface="bold", fontsize = 24))

lay.mat <- rbind(c(1, rep(2, 11)),
                 t(replicate(8, c(6, rep(2, 11)))),
                 rep(3, 12),
                 c(4, rep(5, 11)),
                 t(replicate(8, c(6, rep(5, 11)))))
```

#### Plotting final plots 

```{r Figure 3 - Interaction plots (only mother),fig.height = 14, fig.width=10, dpi = 500}

grid.arrange(A, TD.int.plot, line.plot, B, NTD.int.plot, null.plot, layout_matrix = lay.mat, padding = unit(0.1, "line"))

```


### Interaction plots (Figure 4 a, b) 

```{r}
# Intializing 
rad.vec <- seq(1, 120,1)
plot.list <- list()
arc.df.list <- list()
plot.heat.list <- list()


for (j in 1:nrow(parameter.DF)) { 
  temp.smooth <- smooth.see.list[[j]]
  temp.cent   <- center.list[[j]]

  ang.vec     <- ((1:nrow(temp.smooth)) / nrow(temp.smooth)) * 2 * pi

  ## Calculating for each object center the time the infants spent near it 
  for (l in 1:length(temp.cent)) {
    obj.name <- names(temp.cent[l])
    ## Finding Distance From Object 
    dist.vec    <- sqrt((temp.smooth$x - temp.cent[[l]][1])^2 + (temp.smooth$y - temp.cent[[l]][2])^2)
    ## Find name and fit to factor 
    ## Fixed Distance vector 
    arc.df <- data.frame('ID' = 1:nrow(temp.smooth),
                         'Angle' = ang.vec, 
                         'Dist' = dist.vec,
                         'Obj' = obj.name)
    arc.df <- arc.df %>% dplyr::filter(Dist < max(rad.vec)) 
    arc.df.list[[l]] <- arc.df 
  }
  
  arc.df <- do.call('rbind', arc.df.list) 
  temp.plot <- ggplot(arc.df) 
  for (i in 1:length(rad.vec)) { 
    temp.plot <- temp.plot + geom_path(data = circleFun(r = rad.vec[i]), 
                                       aes(x,y),
                                       color = 'grey', size = 0.75) 
  }
  if (nrow(arc.df) != 0) {
      arc.df[,'Obj'] <- factor(arc.df[,'Obj'], levels = obj.names)
      temp.plot <- temp.plot  + geom_segment(aes(x = Dist * sin(Angle),
                                                 y = Dist * cos(Angle),
                                                 xend = max(rad.vec) * sin(Angle),
                                                 yend = max(rad.vec) * cos(Angle),
                                                 group = factor(paste(ID, Obj)), colour = Obj)
                                                 ,size = 2) 
  }
  plot.list[[j]] <- temp.plot +  
     scale_colour_manual(values = cols, name = element_blank(), drop = FALSE) +
     coord_fixed(ratio = 1) +
    theme(legend.position = 'top', legend.text = element_text(size = 15),
          legend.key.height = unit(0.7, "in"), legend.key.width = unit(0.75, "in")) + 
    guides(colour = guide_legend(override.aes = list(size = 5))) +
       labs(caption = parameter.DF$Name[j]) + 
    theme(plot.caption = element_text(hjust=0.5, size = 16)) 

} 


## Creating plot for legend 
# legend.plot <- ggplot(data.frame()) + geom_point() + scale_colour_manual(values = cols, labels = c(obj.names), name = 'Legend', drop = FALSE) 


full.legend <- get_legend(plot.list[[9]])

```


#### Arranging plots 

```{r, warning = FALSE, echo = FALSE, include = FALSE} 
### Arranging plots 
TD.int.plot <- grid.arrange(plot.list[[3]] + opts, plot.list[[5]] + opts, plot.list[[6]] + opts,
                            plot.list[[8]] + opts, plot.list[[9]] + opts , plot.list[[11]] + opts,
                            padding = unit(0.1, "line"),
                            layout_matrix=rbind(c(1,2,3), c(4,5,6)))

NTD.int.plot <- grid.arrange(plot.list[[1]] + opts, plot.list[[2]] + opts, plot.list[[4]] + opts,
                            plot.list[[7]] + opts, plot.list[[10]] + opts, plot.list[[12]] + opts,
                            padding = unit(0.1, "line"),
                            layout_matrix=rbind(c(1,2,3), c(4,5,6)))

line.plot <- ggplot(NULL) + geom_abline(slope = 0, intercept = 0.5, size = 3) + opts
null.plot <- ggplot(NULL) + opts

A=textGrob("a", gp=gpar(fontface="bold", fontsize = 24))
B=textGrob("b", gp=gpar(fontface="bold", fontsize = 24))

lay.mat <- rbind(c(1, rep(2, 11)),
                 t(replicate(8, c(6, rep(2, 11)))),
                 rep(3, 12),
                 c(4, rep(5, 11)),
                 t(replicate(8, c(6, rep(5, 11)))),
                 rep(7, 12))
```

#### Plotting final plots 

```{r Figure 4 - Interaction plots (full),fig.height = 17, fig.width=10}
grid.arrange(A, TD.int.plot, line.plot, B, NTD.int.plot, null.plot, full.legend, layout_matrix = lay.mat, padding = unit(0.1, "line"))

```

### Distance From Mother (Figure 5 a, b) 

\begin{enumerate} 
\item Double Visit - Larger radius is 1.1 radius of smaller circle 
\item Radiuses looking at Mother Radius untill 30 120 
\end{enumerate} 

```{r distance from mother opt3 , warning = FALSE, echo = FALSE, include = FALSE}

dist.list      <- list()
plot.dist.list <- list()


for (j in 1:nrow(parameter.DF)) { 
  temp.mom.cent <- center.list[[j]][['Mother']][1:2]
  temp.smooth   <- smooth.see.list[[j]]
  p             <- nrow(temp.smooth)
  temp.td       <- parameter.DF[j,'IS.TD']
  rad.vec       <- seq(30, 120, 1)

  ## All visits to the object
  visit.vec     <- sapply(sapply(rad.vec, DoubleVisit, 
                             center.coord = temp.mom.cent,
                             smooth.table = temp.smooth), nrow)
  ex.num.tab    <- Group(which(diff(visit.vec) == 0))
  min.rad       <- rad.vec[ex.num.tab[which.max(ex.num.tab[ ,2] - ex.num.tab[ ,1]), 1]]
  ## Plotting 

  ## Finding Excursions 
  dist.vec   <- sqrt((temp.smooth$x - temp.mom.cent[1])^2 + (temp.smooth$y - temp.mom.cent[2])^2)
  temp.visit <- DoubleVisit(temp.mom.cent, temp.smooth, s.rad = min.rad)
  draw.ex <- rep(NA, p)
  draw.ex[apply(temp.visit, 1, FindMin, dist.vec = dist.vec)] <- apply(temp.visit, 1, FindMin, dist.vec = dist.vec) 
  dist.list[[j]] <- data.frame('IS.TD' = rep(temp.td, p) , 
                               'Name' = rep(parameter.DF$Name[j], p), 
                               'Distance' = dist.vec, 
                               'Excursions' = draw.ex, 
                               'Radius' = rep(min.rad, p),
                               'Frame' = 1:p,
                               'prog.vec' = temp.smooth$prog.vec)

}

dist.df <- do.call(rbind, dist.list)




```


#### Distance from mother - TD (Figure 5 a)

```{r Figure 5 a - Distance mother TD}

TD.dat      <- subset(dist.df, IS.TD == TRUE) 
TD.dat$Name <- factor(TD.dat$Name, 
                       levels = unique(TD.dat$Name))

dist.plot <- ggplot(data = TD.dat  , aes(x = round(Frame / (25 * 60) , 2), y = Distance)) + 
  geom_point(size = 0.75, color = 'blue') + labs(color = "Progression") + 
  labs( y ="Distance (CM)" , x = "Min") + 
  theme_grey() +  
  theme(legend.text=element_text(size=16) , legend.position = 'none', axis.title=element_text(size=22)) + 
  geom_vline(aes(xintercept = Excursions / (25 * 60)) , size = 0.75) + scale_y_continuous(breaks = c(100, 300 ,500)) + 
  geom_hline(aes(yintercept = Radius)) 
  
dist.plot + facet_grid(Name ~ .) + theme(strip.text.y = element_text(size = 22),
                                         plot.title = element_text(size = 22))




```




#### Distance from mother - NTD (Figure 5 b)

```{r Figure 5 b - distance mother NTD }

NTD.dat <- subset(dist.df, IS.TD == FALSE) 
NTD.dat$Name <- factor(NTD.dat$Name, 
                       levels = unique(NTD.dat$Name))
dist.plot <- ggplot(data = NTD.dat  , aes(x = round(Frame / (25 * 60) , 2), y = Distance)) + 
  geom_point(size = 0.75, color = 'red') + labs(color = "Progression") + 
  labs(y ="Distance (CM)" , x = "Min") + 
  theme_grey() +  
  theme(legend.text=element_text(size = 14) , legend.position = 'none', axis.title=element_text(size = 22)) + 
  geom_vline(aes(xintercept = Excursions / (25 * 60) ) , size =0.75 ) + scale_y_continuous(breaks = c(100, 300 ,500)) + 
  geom_hline(aes(yintercept = Radius)) 
  
dist.plot + facet_grid(Name ~ .) + theme(strip.text.y = element_text(size = 22),
                                         plot.title = element_text(size = 22))


```


```{r Testing the difference in excursions}

#### Testing difference 
test.mat <- dist.df %>% 
  select(Excursions, Name, IS.TD) %>%
  group_by(Name) %>% 
  dplyr::summarise('Number_Excursions' = sum(!is.na(Excursions)),
                   'IS.TD'= mean(IS.TD))

td.ex <- test.mat %>% filter(IS.TD == TRUE) %>% select(Number_Excursions) %>% unlist()
ntd.ex <- test.mat %>% filter(IS.TD == FALSE) %>% select(Number_Excursions) %>% unlist()
wilcox.excursion.test <- wilcox.test(td.ex, ntd.ex)


abs.ex.diff <- abs(mean(td.ex) - mean(ntd.ex))


sd.ex <- (sd(td.ex)^2 * (length(td.ex) - 1) + sd(ntd.ex)^2 * (length(ntd.ex) - 1)) /
        (length(ntd.ex) + length(td.ex) - 2)



kable(data.frame('Test' = '# Of excursions',
                 'Wilcoxon p-value' =  wilcox.excursion.test$p.value, 
                 'Abs Difference' = mean(abs.ex.diff) ,
                 'Statistic' = wilcox.excursion.test$statistic,
                 'SD' = sqrt(sd.ex),
                 'Effect Size' = median(outer(td.ex, ntd.ex, '-')) / sqrt(sd.ex)), row.names = FALSE)




```


### Permutation Tests - Number of excursions and time spent ~ Distance 


```{r time spent }

#### Building radius from mother and find % of time spent in that that radius 

rad.vec <- seq(1, 120 ,1)
time.data.frame <- data.frame('Name'     = rep(NA, length(rad.vec) * 12),
                              'Distance' = rep(NA, length(rad.vec) * 12),
                              'Time.Spent'  = rep(NA, length(rad.vec) * 12), 
                              'TD'    = rep(NA, length(rad.vec) * 12))

m <- 0
for (i in 1:nrow(parameter.DF)) { 
  temp.smooth   <- smooth.see.list[[i]]
  temp.mom.cent <- center.list[[i]][['Mother']]
  temp.dist.vec <- (temp.smooth$x - temp.mom.cent[1])^2 + (temp.smooth$y - temp.mom.cent[2])^2 
  p             <- nrow(temp.smooth)
  for (j in 1:length(rad.vec)) {
    m <- m + 1 
    spent.mom <- sum(temp.dist.vec <= rad.vec[j]^2)
    time.data.frame[m,c('Name', 'TD')] <- c(parameter.DF$Name[i], parameter.DF[i,'IS.TD'])
    time.data.frame[m,c('Distance', 'Time.Spent')] <- c(rad.vec[j],  spent.mom / p)
  }  
}

## Not Averaged 


```


Using permutation testing to compare the mean curves of excursions ~ distance and % of time near mother ~ distance.


```{r}

#### Time spent in radius from mother 
time.data.frame.perm <- time.data.frame
x <- aggregate(Time.Spent ~ TD + Distance, time.data.frame, mean)
true.dist <- mean((subset(x, TD == TRUE)[,3] - subset(x, TD == FALSE)[,3])^2)

temp.dist <- NA
for (i in 1:1000){
  time.data.frame.perm[,4] <- TRUE
  time.data.frame.perm[time.data.frame.perm[,1] %in% sample(unique(parameter.DF$Name), 6),4] <- FALSE
  x <- aggregate(Time.Spent ~ TD + Distance, time.data.frame.perm, mean)
  temp.dist[i] <- mean((subset(x, TD == TRUE)[,3] - subset(x, TD == FALSE)[,3])^2)
}

p.val.mom.dist <- 1 - mean(true.dist > c(temp.dist, true.dist))

#### Excrursions  (defined as visit to radius from mother)
#### Creating data frame of time visit for each radius from 5 to 150 for each infant 
rad.vec <- seq(1, 120 ,1)
vis.data.frame <- data.frame('Name'      = rep(NA, length(rad.vec) * 12),
                              'Distance' = rep(NA, length(rad.vec) * 12),
                              'Excursion'= rep(NA, length(rad.vec) * 12), 
                              'TD'       = rep(NA, length(rad.vec) * 12))


m <- 0
for (i in 1:nrow(parameter.DF)) { 
  temp.smooth   <- smooth.see.list[[i]]
  temp.mom.cent <- center.list[[i]][['Mother']]
  p             <- nrow(temp.smooth)
  for (j in 1:length(rad.vec)) {
    m <- m + 1 
    visit.mom <- nrow(DoubleVisit(smooth.table = temp.smooth, center.coord = temp.mom.cent[1:2], rad.vec[j]))
    vis.data.frame[m,c('Name', 'TD')] <- c(parameter.DF$Name[i], parameter.DF[i,'IS.TD'])
    vis.data.frame[m,c('Distance', 'Excursion')] <- c(rad.vec[j],  ifelse(is.null(visit.mom), 0, visit.mom) )
  }  
}


vis.data.frame.perm <- vis.data.frame
x <- aggregate(Excursion ~ TD + Distance, vis.data.frame, mean)
true.ex <- mean((subset(x, TD == TRUE)[,3] - subset(x, TD == FALSE)[,3])^2)
temp.ex <- NA

for (i in 1:1000){
  vis.data.frame.perm[,4] <- TRUE  
  vis.data.frame.perm[vis.data.frame.perm[,1] %in% sample(unique(parameter.DF$Name), 6),4] <- FALSE
  x <- aggregate(Excursion ~ TD + Distance, vis.data.frame.perm, mean)
  temp.ex[i] <- mean((subset(x, TD == TRUE)[,3] - subset(x, TD == FALSE)[,3])^2) 
}

p.val.mom.excu <- 1 - mean(true.ex > c(temp.ex, true.ex))

```

### Difference in curves (Figure S1 a, b, c, d)

```{r Figure S1 a, b, c, d, fig.height= 16, fig.width=16}


## By Condition 
cond.plot <- ggplot(time.data.frame, aes(x = Distance, y = Time.Spent, color = TD, group = Name)) + 
  geom_line(size = 1.25) + 
  ggtitle("Percent Time Spent Near Mother ") +
  labs( y = "% Of Time", x ="Distance from mother (cm)") +
  theme(text = element_text(size=22), 
        legend.position = c(0.1, 0.9),
        legend.background = element_blank(),
        legend.title = element_blank(),
        legend.key.height = unit(0.5, "in"), 
        legend.key.width = unit(0.65, "in")) + 
  scale_colour_discrete(labels = c("NTD", "TD")) +
  opts.perm



## Averaged 
df.cover <- aggregate(Time.Spent ~ TD + Distance, time.data.frame, FUN = function(x) c('Percentage' = mean(x),                                                                           'SD' = sd(x)))

df.cover <- do.call(data.frame, df.cover)
colnames(df.cover) <- c('Group', 'Radius', 'Percentage_Covered', 'SD')


## With CI 
CI.cover.plot <- ggplot(df.cover, aes(x = Radius, y = Percentage_Covered, color = Group)) + geom_line(size = 1.5) + geom_ribbon(aes(ymin = Percentage_Covered - 1.96 * sqrt(Percentage_Covered * (1 - Percentage_Covered) / 6), ymax = Percentage_Covered + 1.96 * sqrt(Percentage_Covered * (1 - Percentage_Covered) / 6), alpha = 0.05 , fill = Group), show.legend = FALSE) +  ggtitle("Average Percent Of Time Spent Near Mother") + 
  labs( y = "% Of Time", x ="Distance from mother (cm)")  + theme(text = element_text(size=22), legend.position = 'none') + opts.perm


## Not Averaged 

## By Condition 
vis.plot <- ggplot(vis.data.frame, aes(x = Distance, y = Excursion, color = TD, group = Name)) + geom_line(size = 1.25) + ggtitle("Number of Visits to Mother") +
  labs( y = "Number Of Visits", x ="Distance from mother (cm)") + theme(text = element_text(size=22), legend.position = 'none') + opts.perm

## Averaged 
df.visit <- aggregate(Excursion ~ TD + Distance, vis.data.frame, FUN = function(x) c('Visits' = mean(x),                                                                           'SD' = sd(x)))

df.visit <- do.call(data.frame, df.visit)
colnames(df.visit) <- c('Group', 'Radius', 'Visits', 'SD')

## With CI
CI.vis.plot <- ggplot(df.visit, aes(x = Radius, y = Visits, color = Group)) + geom_line(size = 1.5) + geom_ribbon(aes(ymin = Visits - 1.96 * SD * sqrt(1 / 6), ymax = Visits + 1.96 * SD * sqrt(1 / 6), alpha = 0.05 , fill = Group), show.legend = FALSE) +  ggtitle("Average Number of Visits To Mother") +
  labs( y = "Number Of Visits", x ="Distance from mother (cm)")  +  theme(text = element_text(size=22), legend.position = 'none') + opts.perm

grid.arrange(cond.plot, CI.cover.plot, vis.plot, CI.vis.plot, layout_matrix = rbind(c(1,2),c(3,4))) 


```

#### Testing Distance between curves 

Testing the hypothesis that the mean curve of the TD infants is higher than that of the NTD infants

```{r}

kable(data.frame('Tests' = c('% Near mother ~ radius', '# Excursions ~ radius'),
                 'Distance between mean curves' = c(sqrt(true.dist), sqrt(true.ex)), 
                 'Permutation P-value' = c(p.val.mom.dist, p.val.mom.excu),
                 'Adjusted BH' = p.adjust(c(p.val.mom.dist, p.val.mom.excu), 'BH')))
# 
# print(paste('Distance between mean curves is', sqrt(true.dist), 'P-value of permutation test (Distance) is ',p.val.mom.dist))
# print(paste('Distance between mean curves is', sqrt(true.ex), 'P-value of permutation test (Excursions) is ',p.val.mom.excu))

```


### Mors plots of touching (Figure 6) 

Mors plot of the frame in which the infant is touching the mother. 

```{r Figure 6 ,warning = FALSE, echo = FALSE, include = FALSE}
touch.list <- list()
for (i in 1:length(smooth.see.list)) { 
  temp.df        <- smooth.see.list[[i]]
  temp.df        <- temp.df %>% mutate('Frames' = 1:nrow(temp.df))
  temp.name      <- names(smooth.see.list)[i]
  ## Find Mom Center 
  ## Touching 
  touch.list[[i]]<- data.frame('Name_Infant'   = parameter.DF[i, 'Name'], 
                               'IS.TD'  = parameter.DF[i, 'IS.TD'],
                               'Frames' = 1:nrow(temp.df),
                               'Touch'  = temp.df[ ,'Touch'])
  
}

touch.df <- do.call('rbind', touch.list)
touch.df[touch.df[ ,'Touch'] == 0, 'Touch'] <- NA


touch.df <- touch.df %>%
  mutate(Frame_Touch = Frames * Touch) %>% 
  dplyr::add_count(Name_Infant)
 

aggregate(Frames ~ Name_Infant , touch.df, max)

### Seperating the dataframe 
touch.df.TD  <- touch.df %>% filter(IS.TD == TRUE) 
touch.df.NTD <- touch.df %>% filter(IS.TD == FALSE)



### Plotting 
## TD 
# touch.df %>% ggplot(aes(y = 1, x = Frame_Touch, color = IS.TD)) + 
#   geom_point(size = 2, color = 'blue') + 
#   geom_vline(xintercept = n) + 
#   facet_grid(Name ~ .)  +
#   theme(axis.title.y=element_blank(),
#         axis.text.y=element_blank(),
#         axis.ticks.y=element_blank(),
#         panel.spacing = unit(0, "lines")) + 
#   ggtitle('Contact With Mother ~ Frames') + opts.perm
# 


### Plotting 
## TD 
TD.touch.plot <- touch.df.TD %>% ggplot(aes(y = 1, x = Frame_Touch)) + 
  geom_point(size = 2, color = 'blue') + 
    geom_vline(aes(xintercept = n), size = 1.5) + 
  facet_grid(Name_Infant ~ .) + opts.perm +
  theme(axis.title.x = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.line = element_blank(),
        panel.spacing = unit(0.75, "lines"),
        strip.text = element_text(size = 8)) + 
  ylab('Touch') + xlab('')
  

## NTD 

NTD.touch.plot <- touch.df.NTD %>% ggplot(aes(y = 1, x = Frame_Touch)) + 
  geom_point(size = 2, color = 'red') + 
    geom_vline(aes(xintercept = n), size = 1.5) +
  facet_grid(Name_Infant ~ .) + opts.perm + 
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank(),
        panel.spacing = unit(0.75, "lines"),
        strip.text = element_text(size = 8)) + 
  xlab('Frames') +
  ylab('Touch') 
   


dat <- data.frame('x' = 1:6, 'y' = 1:6, 'type' = rep(c("TD", "NTD"), 3))

leg.plot <- ggplot(dat) + geom_line(aes(x = x, y = y, color = type)) + 
  scale_colour_manual(values = c("blue", "red"), 
                      breaks = c("TD", "NTD"),
                      labels = c("TD", "NTD")) +
  guides(colour = guide_legend(override.aes = list(size = 2),
                               direction = "horizontal",
                               title = element_blank())) +
  theme(legend.key.width = unit(1.5, "cm"),
        legend.text = element_text(size = 12))



full.legend <- get_legend(leg.plot)


```



````{r Figure 6} 
line.plot <- ggplot(NULL) + geom_abline(slope = 0, intercept = 0.5, size = 3) + opts
null.plot <- ggplot(NULL) + opts

A=textGrob("a", gp=gpar(fontface="bold", fontsize = 24))
B=textGrob("b", gp=gpar(fontface="bold", fontsize = 24))

lay.mat <- rbind(c(1, rep(2, 11)),
                 t(replicate(8, c(6, rep(2, 11)))),
                 rep(3, 12),
                 c(4, rep(5, 11)),
                 t(replicate(8, c(6, rep(5, 11)))))

grid.arrange(A, TD.touch.plot , line.plot, B, NTD.touch.plot, null.plot, layout_matrix = lay.mat, padding = unit(0.1, "line"))

```




### Comparing different statistics (Figure 7)

Testing the difference of different statistics (Wilcoxon test), the data was transformed for plotting. 
\begin{enumerate} 
\item Square root of excursions to the mother (at radius 100 CM) 
\item Logit % of time spent at mother vicinity (at radius 100 CM)
\item Progression segments speed (cm/sec)
\item Logit of % of room covered 
\item Speed outside of mother's vicinity (100 CM) (cm/sec)
\item Square root numnber of contact episodes 
\item Logit of % of contact time 
\end{enumerate}

```{r Comparing TD & NTD}
### Testing Number Of Excursions at 100 CM 
vis.100 <- filter(vis.data.frame, Distance == 100)[,3]

### According to distance list 
vis.dist <- unlist(lapply(dist.list, function(x) ifelse(all(is.na(x$Excursions)), 
                                                 1, length(na.omit(unique(x$Excursions))))))

### Time Spent At Mother Vicinity 
time.spent.100 <- filter(time.data.frame, Distance == 100)[,3]

### Testing Speed 
speed.vec.with.ling <- unlist(lapply(smooth.see.list, function(df) mean(sqrt(df$v.x^2 + df$v.y^2))))
ProgSpeed <- function(df) {
  df <- df[which(df$prog.vec == 1), ]
  return(mean(sqrt(df$v.x^2 + df$v.y^2)))
}

speed.vec.only.prog <- unlist(lapply(smooth.see.list, ProgSpeed))

### Testing Room Coverage 
cover.vec <-  unlist(lapply(smooth.see.list, CountMap)) 

touch.avg.temp <- NA; touch.num.temp <- NA; dist.temp <- NA; temp.ling <- NA; 
### Touches of Mother
for (i in 1:length(smooth.see.list)) { 

  temp.df        <- smooth.see.list[[i]]
  temp.df        <- temp.df %>% mutate('Frames' = 1:nrow(temp.df))
  temp.name      <- names(smooth.see.list)[i]
  ## Find Mom Center 
  ## Touching 
  temp.touch            <- temp.df[ ,'Touch']
  ## Average touching throuhout session 
  
  touch.avg.temp[i]     <- mean(temp.touch)
  ## Number of toching 
  touch.num.temp[i]     <- nrow(Group(temp.df[as.logical(temp.touch),'Frames']))
  ## Distance normalised outside mother 80CM
  ## Mom Location 
  temp.mom.cent <- center.list[[i]][['Mother']][1:2]
  out.mom.vec.100   <- sqrt((temp.df$x - temp.mom.cent[1])^2 + (temp.df$y - temp.mom.cent[2])^2) > 100

  dist.temp[i] <- sum(sqrt(temp.df[out.mom.vec.100,'v.x']^2 + temp.df[out.mom.vec.100,'v.y']^2)) / sum(out.mom.vec.100)
  ## Lingering Normalized 
  temp.ling[i] <- sum(!temp.df$prog.vec) / nrow(temp.df)
}

### Segments to Mother 

### Transformed data 
test.df <- data.frame('Name' = parameter.DF$Name, 
                      'Excursions.100.CM' = sqrt(vis.100), ## Square root 
                      'Time.Mother.Radius.100.CM' = Logit(time.spent.100), ## logit 
                      'Speed.Prog' = speed.vec.only.prog,
                      'Avg.Cover' = Logit(cover.vec), ## logit  maybe can add time.spent.vec
                      'Speed.Outside.Mother.Radius.100.CM' = dist.temp,
                      'Touches.Num' = sqrt(touch.num.temp), ## square root 
                      'Touches.Duration' = Logit(touch.avg.temp), ## logit 
                      'TD' = parameter.DF[ ,'IS.TD'])

## Function to control string length 
swr = function(string, nwrap=25) {
  paste(strwrap(string, width=nwrap), collapse="\n")
}

### Original without transformations 
org.test.df <- data.frame('Name' = parameter.DF$Name, 
                          'Excursions.100.CM' = (vis.100), ## Square root 
                          'Time.Mother.Radius.100.CM' = Logit(time.spent.100), ## logit 
                          'Speed.Prog' = speed.vec.only.prog,
                          'Avg.Cover' = (cover.vec), ## logit 
                          'Speed.Outside.Mother.Radius.100.CM' = dist.temp,
                          'Touches.Num' = (touch.num.temp), ## square root 
                          'Touches.Duration' = (touch.avg.temp), ## logit 
                          'TD' = parameter.DF[ ,'IS.TD'])





p.vec      <- rep(NA, 6)
diff.vec   <- rep(NA, 6)
W.vec      <- rep(NA, 6) 
effect.vec <- rep(NA, 6) 
sd.vec     <- rep(NA, 6)

for (i in 2:8) { 
  x.td  <- org.test.df[org.test.df['TD'] == TRUE, i]
  x.ntd <- org.test.df[org.test.df['TD'] == FALSE, i]
  temp.test  <- wilcox.test(x.td, x.ntd)
  sd.vec[i-1]     <- (sd(x.td)^2 * (length(x.td) - 1) + sd(x.ntd)^2 * (length(x.ntd) - 1)) / 
                      (length(x.td) + length(x.ntd) - 2 )
  effect.vec[i-1] <- median(outer(x.td, x.ntd, `-`)) / sd(c(x.td, x.ntd))
  p.vec[i-1]      <- temp.test$p.value
  W.vec[i-1]      <- temp.test$statistic
  diff.vec[i-1]   <- abs(mean(x.td) - mean(x.ntd))
}

p.vec.adj <- p.adjust(p.vec, 'BH')
names(p.vec) <- colnames(test.df[ ,2:8])



box.df <- test.df %>% 
  select(-Name) %>%
  plyr::rename(c('Excursions.100.CM' = paste('Sqrt Number \n of Excursions 100 (cm) \n P =', round(p.vec[1], 4)),
                 'Time.Mother.Radius.100.CM' = paste('Logit % of Time \n Near Mother 100 (cm) \n P =', round(p.vec[2], 4)), 
                 'Speed.Prog' = paste('Progression Speed (cm/sec) \n P =', round(p.vec[3], 4)), 
                 'Avg.Cover' = paste('Logit % Room Covered \n P =', round(p.vec[4], 4)), 
                 'Touches.Num' = paste('Sqrt # Contact Episodes \n  P =', round(p.vec[5], 4)), 
                 'Touches.Duration' = paste('Logit % Of Contact Time \n  P =', round(p.vec[6], 4)),
                 'Speed.Outside.Mother.Radius.100.CM' = paste('Speed (cm/sec) outside of \n mother\'s vicinity 100 (cm) \n  P =', round(p.vec[7], 4)))) %>% 
  melt(id.var = 'TD') 
box.df[,'TD'] <- factor(box.df[,'TD'], levels = c('TRUE', 'FALSE'))

```


Effect size is given by $\frac{Med_{i,j}(x_i - y_j)}{SD}$. All tests conducted are Wilcoxon sum rank test, which do not require assumptions regarding the underlying distribution of observations. 


````{r Figure 7, fig.width = 17, fig.height = 11}
### Plotting the boxplots 
ggplot(box.df, aes(y = value, x = variable, color = TD, fill = TD, group = TD)) + 
  geom_boxplot(alpha = 0.25, notch = FALSE) + 
  ggtitle("") + 
  scale_fill_manual(values = c('blue', 'red'), labels = c("TD", "NTD")) + 
  scale_color_manual(values = c('blue', 'red'), labels = c("TD", "NTD")) +
  labs( y = "", x = "") + 
  facet_wrap( ~ variable, scales = 'free', ncol = 4)+ 
  opts.perm +  
  theme(strip.text = element_text(size = 16), 
        plot.title = element_text(size = 22),
        legend.text = element_text(size = 16),
        axis.text.x = element_blank(),
        legend.title = element_blank(),
        legend.key.height = unit(0.85, "in"), 
        legend.key.width = unit(0.85, "in"),
        legend.position = c(0.8, 0.35))
       # legend.position = 'bottom')  

kable(data.frame('Tests' = colnames(test.df[ ,2:8]),
                 'Un-Adjusted P-value' = p.vec, 
                 'BH P-value' = p.vec.adj,
                 'Abs Difference' = diff.vec,
                 'Statistic' = W.vec,
                 'SD' = sqrt(sd.vec),
                 'Effect Size' = effect.vec / sqrt(sd.vec)), row.names = FALSE)


```


