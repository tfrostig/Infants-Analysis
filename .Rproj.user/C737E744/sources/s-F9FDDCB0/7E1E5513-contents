### Simulation 

library(MASS)
p <- 3 

expectedVal <- function(X, col.ind.1, mu, Sigma) { 
  col.ind.2 <- setdiff(1:ncol(Sigma), col.ind.1)
  Sigma11   <- Sigma[col.ind.1, col.ind.1, drop = FALSE]
  Sigma12   <- Sigma[col.ind.1, col.ind.2, drop = FALSE]
  Sigma22   <- Sigma[col.ind.2, col.ind.2, drop = FALSE]
  mu.cond   <- mu[col.ind] + Sigma12 %*% solve(Sigma22) %*% (X[col.ind.2] - mu[col.ind.2])
  return(mu.cond)
}

cor.mat <- cbind(c(1, 0.5, 0.5),
                 c(0.5, 1, 0.5),
                 c(0.5, 0.5, 1))
mu      <- c(1, 0, 2)

calcR <- function(col.ind.1, Sigma) {
  col.ind.2 <- setdiff(1:ncol(Sigma), col.ind.1)
  R.mat     <- cov2cor(Sigma)
  c.vec     <- R.mat[col.ind.2, col.ind.1, drop = FALSE]
  return(t(c.vec) %*% solve(R.mat[col.ind.2, col.ind.2, drop = FALSE]) %*% c.vec)
}


calcR(1, cor.mat)
calcMahlanobis <- fucntion(x, mu, Sigma) { 
  p <- ncol(Sigma)
  for (i in 1:p) { 
    col.ind.1 <- i
    col.ind.2 <- setdiff(1:p, i)
    (1 - calcR(col.ind.1, Sigma))^(-0.5) * (x[col.ind.1] - solve(t(x[col.ind.2]) %*% x[col.ind.2]) %*% t(x[col.ind.2]) %*% x[col.ind.1] * (x[col.ind.1] - expectedVal(x, col.ind.1, mu, Sigma))) * (x[col.ind.1] - mu[col.ind.1]) / Sigma[col.ind.1, col.ind.1]
    
  }  
}